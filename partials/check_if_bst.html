<!DOCTYPE html>
<html>
  <head>     <link href="prism.css" rel="stylesheet"> <script type="text/javascript-lazy"  >  	var admobid = {}; if( /(android)/i.test(navigator.userAgent) ) {     admobid = {            banner: 'ca-app-pub-5830283354936773/5921375320',        interstitial: 'ca-app-pub-5830283354936773/1902239267'     }; } else if(/(ipod|iphone|ipad)/i.test(navigator.userAgent)) {     admobid = {            banner: 'ca-app-pub-6869992474017983/4806197152',         interstitial: 'ca-app-pub-6869992474017983/7563979554'     }; } else {     admobid = {              banner: 'ca-app-pub-6869992474017983/8878394753',         interstitial: 'ca-app-pub-6869992474017983/1355127956'     }; } if(( /(ipad|iphone|ipod|android|windows phone)/i.test(navigator.userAgent) )) {     document.addEventListener('deviceready', initApp, false); } else {     initApp(); }  function initApp() {     if (! AdMob ) { alert( 'admob plugin not ready' ); return; }       AdMob.createBanner( {         adId: admobid.banner,         isTesting: false,         overlap: false,         offsetTopBar: false,         position: AdMob.AD_POSITION.BOTTOM_CENTER,         bgColor: 'black'     } );      AdMob.prepareInterstitial({         adId: admobid.interstitial,         autoShow: true     }); }    </script></head>
  <body style="background-color:white;" >
	
	<div class="topcoat-navigation-bar" ng-controller="HomeCtrl">
	  <div class="topcoat-navigation-bar__item left quarter">
		<a class="topcoat-icon-button--quiet" ng-click="slidePage('/','modal')">
		  <span class="topcoat-icon home-icon"></span>
		</a>
	  </div>
	  <div class="topcoat-navigation-bar__item center half">
		<h1 class="topcoat-navigation-bar__title">Cake</h1>
	  </div>
	</div>
	
	<script type="text/javascript" src="prism.js"></script>

	<pre  ng-prism  class="language-python"><code>
		





'''
	Problem: Given a binary tree, check if it is a binary search tree or not. A binary search tree is a binary tree 
	such that all nodes to the left of root are smaller than the root node and all nodes to the right of 
	the root node are larger than the root node.

	Solution 1: Iterate through the tree and compare each node with its left and right node. If anywhere the left and right 
	node values violates, return False else return True. 

	Problem(Incorrect solution): Fails for a tree
								3
							  /  \
							 2    5
							/ \
						   1   4

	Solution 2: Check if the maximum value in the left subtree is smaller than the node and minimum value in the right 
	subtree is greater than the node.

	Inefficient solution as for each node, first we will have to find the min and max value and compare it. It will 
	traverse the same part of the tree many times. 

	Solution 3: Using a helper function BSTUtil(node, max, min) we can traverse down the tree keeping a track of max and
	min value. This will traverse each node only once. 
'''


def BSTUtil(node, maximum, minimum):
	''' Helper function to check if tree is a bst'''
	if node is None:
		return True
	
	# If the node is less than min value or greater than max value, it returns False
	if (node.data < minimum or node.data > maximum):
		return False

	return BSTUtil(node.left, node.data, minimum) and BSTUtil(node.right, maximum, node.data)


def checkBST(node):
	''' 
		Function to check if a binary tree is a bst or not
	'''
	if node is None:
		return True

	# We call th helper function by passing the maximum and minimum values initially
	if BSTUtil(node, 999999999, -99999999999):
		return True
	else:
		return False
		
		
		
        </code></pre>
  </body>
</html>		
		
